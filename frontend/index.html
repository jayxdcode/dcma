<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hitori ⊙⁠﹏⁠⊙</title>
  <script>
    // Minimal fix for auto load eruda
    (function() {
      if (typeof window.eruda !== 'undefined') return;
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      
      const script = document.createElement('script');
      script.src = isDiscordProxy ? "/src/eruda/eruda.js" : "//cdn.jsdelivr.net/npm/eruda";
      document.body.appendChild(script);
      script.onload = () => {
        window.eruda.init();
        console.log('[eruda] i\'m in, fellas');
      };
    })();
  </script>
  <script>
    // iframe debugger version 2
    function iframeDebug() {
      const iframe = document.querySelector('#hitori-yt-player');
      if (!iframe) {
        console.error("Iframe #hitori-yt-player not found.");
        return;
      }
      
      // Create the Toggle Button
      const btn = document.createElement('button');
      btn.innerHTML = 'DEBUG MODE: OFF';
      btn.style.cssText = `
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 2147483647;
        padding: 12px 20px;
        background: #2c2f33;
        color: white;
        border: 2px solid #5865F2;
        border-radius: 8px;
        cursor: pointer;
        font-family: sans-serif;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    `;
      
      let isVisible = false;
      // Store original styles to revert accurately
      const originalStyles = iframe.style.cssText;
      
      btn.onclick = () => {
        if (!isVisible) {
          // Take over the whole view
          iframe.style.setProperty('position', 'fixed', 'important');
          iframe.style.setProperty('top', '0', 'important');
          iframe.style.setProperty('left', '0', 'important');
          iframe.style.setProperty('width', '100vw', 'important');
          iframe.style.setProperty('height', '100vh', 'important');
          iframe.style.setProperty('z-index', '2147483646', 'important');
          iframe.style.setProperty('pointer-events', 'auto', 'important');
          iframe.style.setProperty('display', 'block', 'important');
          
          btn.innerHTML = 'DEBUG MODE: ON';
          btn.style.background = '#ed4245';
          
          if (typeof injectEruda === 'function') injectEruda();
        } else {
          // REVERT: Clear the inline styles we added and restore original inline styles
          iframe.style.cssText = originalStyles;
          
          btn.innerHTML = 'DEBUG MODE: OFF';
          btn.style.background = '#2c2f33';
        }
        isVisible = !isVisible;
      };
      
      document.body.appendChild(btn);
    }
    
    (function() {
      // Assign to window for manual console access
      window.iframeDebug = iframeDebug;
      setTimeout(() => { console.log('[debugger.js] Debugger initialized.'); }, 5000);
    })();
  </script>
  <script>
    // inject-before-yt-api.js
    (function() {
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      if (!isDiscordProxy) {
        console.log("[yt-api-patcher] skipped patching. reason: not in a discord context")
        return;
      }
      
      const HOST = location.origin + "/yt";
      
      // Ensure YTConfig.host exists before the API checks it
      window.YTConfig = window.YTConfig || {};
      window.YTConfig.host = HOST;
      
      // Patch creation of players once API registers YT.Player
      function patchPlayer() {
        if (!window.YT || !window.YT.Player) return;
        if (window.YT.Player.__patched) return;
        
        const RealPlayer = window.YT.Player;
        
        function PatchedPlayer(el, opts) {
          opts = opts || {};
          // force host to our proxy
          opts.host = HOST;
          return new RealPlayer(el, opts);
        }
        // preserve prototype and static props
        PatchedPlayer.prototype = RealPlayer.prototype;
        Object.getOwnPropertyNames(RealPlayer).forEach(k => {
          if (!(k in PatchedPlayer)) PatchedPlayer[k] = RealPlayer[k];
        });
        PatchedPlayer.__patched = true;
        window.YT._RealPlayer = RealPlayer;
        window.YT.Player = PatchedPlayer;
      }
      
      // Hook into the usual ready callbacks and poll fallback
      const orig1 = window.onYouTubeIframeAPIReady;
      window.onYouTubeIframeAPIReady = function() {
        if (typeof orig1 === "function") try { orig1(); } catch (e) {}
        patchPlayer();
      };
      const orig2 = window.onYouTubePlayerAPIReady;
      window.onYouTubePlayerAPIReady = function() {
        if (typeof orig2 === "function") try { orig2(); } catch (e) {}
        patchPlayer();
      };
      
      // Poll until available (cleans up)
      const t = setInterval(() => {
        patchPlayer();
        if (window.YT && window.YT.Player && window.YT.Player.__patched) {
          console.log("[yt-api-patcher] patch done")
          clearInterval(t);
        }
      }, 60);
    })();
  </script>
  <script>
    // parent-inject-single-hitori-v1.js
    // Targets only #hitori-yt-player, waits for YT.Player.__patched and injects embed patcher script via src.
    
    (function() {
      'use strict';
      
      const FIX_SCRIPT_URL = location.origin + '/raw/jayxdcode/dcma/main/public/embed-patcher.js'; // replace with your remote URL
      const IFRAME_ID = 'hitori-yt-player';
      const WAIT_FOR_PATCHER_MS = 6000; // wait up to this for YT.Player.__patched inside iframe
      const POLL_INTERVAL = 120;
      
      function log() { try { console.log.apply(console, ['[parent->hitori]'].concat(Array.from(arguments))); } catch (e) {} }
      
      function getIframe() { return document.getElementById(IFRAME_ID) || null; }
      
      // Poll until predicate true or timeout. predicate runs in parent but inspects iframe.contentWindow safely with try/catch.
      function waitForIframePredicate(iframe, predicate, timeoutMs) {
        return new Promise((resolve) => {
          const start = Date.now();
          (function poll() {
            try {
              if (!iframe) return resolve(false);
              let ok = false;
              try { ok = predicate(iframe.contentWindow); } catch (e) { ok = false; }
              if (ok) return resolve(true);
            } catch (e) {}
            if (Date.now() - start >= timeoutMs) return resolve(false);
            setTimeout(poll, POLL_INTERVAL);
          })();
        });
      }
      
      // Inject script into iframe (prepend to head or documentElement)
      function injectScript(iframe, srcLink) {
        try {
          const doc = iframe.contentDocument;
          if (!doc) throw new Error('iframe.contentDocument not available');
          const s = doc.createElement('script');
          s.type = 'text/javascript';
          s.src = srcLink;
          (doc.head || doc.documentElement).prepend(s);
          log('injected script text into iframe');
          return true;
        } catch (err) {
          log('injectScript failed:', err && err.message);
          return false;
        }
      }
      
      // Try to call the embed hook if present
      async function callEmbedHookIfPresent(iframe) {
        try {
          const w = iframe.contentWindow;
          if (!w) return false;
          if (typeof w.__embedFixFixAll === 'function') {
            try {
              const rv = w.__embedFixFixAll();
              if (rv && typeof rv.then === 'function') {
                await rv;
                log('embed hook (promise) resolved');
              } else {
                log('embed hook (sync) invoked');
              }
              return true;
            } catch (e) {
              log('embed hook threw:', e && e.message);
              return false;
            }
          } else {
            log('embed hook not found in iframe');
            return false;
          }
        } catch (e) {
          log('callEmbedHookIfPresent err:', e && e.message);
          return false;
        }
      }
      
      // Main flow
      (async function main() {
        const iframe = getIframe();
        if (!iframe) {
          log('iframe #' + IFRAME_ID + ' not found on page');
          return;
        }
        log('found iframe id=' + IFRAME_ID + ' src=', iframe.getAttribute && iframe.getAttribute('src'));
        
        // Wait for YT patcher inside iframe (safe to access contentWindow properties; catch exceptions)
        const patched = await waitForIframePredicate(iframe, (win) => {
          try {
            return !!(win && win.YT && win.YT.Player && win.YT.Player.__patched);
          } catch (e) { return false; }
        }, WAIT_FOR_PATCHER_MS);
        
        log('YT.Player.__patched present inside iframe?', patched);
        
        let injected = false;
        try {
          // try to access iframe.document to ensure we can write into it
          const canAccess = !!iframe.contentDocument;
          if (!canAccess) {
            log('iframe.contentDocument inaccessible (cross-origin?) — cannot inject script');
          } else {
            injected = injectScript(iframe, FIX_SCRIPT_URL);
          }
        } catch (e) {
          log('injection attempt threw:', e && e.message);
        }
        
        // attempt to call hook even if we didn't inject (in case it was already present)
        const hookCalled = await callEmbedHookIfPresent(iframe);
        if (!hookCalled && injected) {
          // give it a tick then try again
          await new Promise(r => setTimeout(r, 160));
          await callEmbedHookIfPresent(iframe);
        }
        
        // final verification log: sample a root-relative img or link if accessible
        try {
          const doc = iframe.contentDocument;
          if (doc) {
            const imgs = doc.querySelectorAll('img[src^="/"]');
            const links = doc.querySelectorAll('link[href*="fonts.gstatic.com"], link[href^="/"]');
            log('post-inject sample counts: images root-relative=', imgs.length, 'link candidates=', links.length);
          }
        } catch (e) {
          log('final verification read failed:', e && e.message);
        }
        
        log('done injection attempt for #' + IFRAME_ID);
      })();
      
      // expose helper to retry from console
      window.__parentInjectHitori_retry = function() { try { main(); } catch (e) { log('manual retry threw', e && e.message); } };
      
    })();
  </script>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>