<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hitori ⊙⁠﹏⁠⊙</title>
  <script>
    // Minimal fix for auto load eruda
    (function() {
      if (typeof window.eruda !== 'undefined') return;
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      
      const script = document.createElement('script');
      script.src = isDiscordProxy ? "/src/eruda/eruda.js" : "//cdn.jsdelivr.net/npm/eruda";
      document.body.appendChild(script);
      script.onload = () => {
        window.eruda.init();
        console.log('[eruda] i\'m in, fellas');
      };
    })();
  </script>
  <script src="/raw/jayxdcode/dcma/refs/heads/main/public/debugger.js"></script>
  <script>
    // inject-before-yt-api.js
    (function() {
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      if (!isDiscordProxy) {
        console.log("[yt-api-patcher] skipped patching. reason: not in a discord context")
        return;
      }
      
      const HOST = location.origin + "/yt";
      
      // Ensure YTConfig.host exists before the API checks it
      window.YTConfig = window.YTConfig || {};
      window.YTConfig.host = HOST;
      
      // Patch creation of players once API registers YT.Player
      function patchPlayer() {
        if (!window.YT || !window.YT.Player) return;
        if (window.YT.Player.__patched) return;
        
        const RealPlayer = window.YT.Player;
        
        function PatchedPlayer(el, opts) {
          opts = opts || {};
          // force host to our proxy
          opts.host = HOST;
          return new RealPlayer(el, opts);
        }
        // preserve prototype and static props
        PatchedPlayer.prototype = RealPlayer.prototype;
        Object.getOwnPropertyNames(RealPlayer).forEach(k => {
          if (!(k in PatchedPlayer)) PatchedPlayer[k] = RealPlayer[k];
        });
        PatchedPlayer.__patched = true;
        window.YT._RealPlayer = RealPlayer;
        window.YT.Player = PatchedPlayer;
      }
      
      // Hook into the usual ready callbacks and poll fallback
      const orig1 = window.onYouTubeIframeAPIReady;
      window.onYouTubeIframeAPIReady = function() {
        if (typeof orig1 === "function") try { orig1(); } catch (e) {}
        patchPlayer();
      };
      const orig2 = window.onYouTubePlayerAPIReady;
      window.onYouTubePlayerAPIReady = function() {
        if (typeof orig2 === "function") try { orig2(); } catch (e) {}
        patchPlayer();
      };
      
      // Poll until available (cleans up)
      const t = setInterval(() => {
        patchPlayer();
        if (window.YT && window.YT.Player && window.YT.Player.__patched) {
          console.log("[yt-api-patcher] patch done")
          clearInterval(t);
        }
      }, 60);
    })();
  </script>
  <script>
// parent-inject-single-hitori-v1.js
// Targets only #hitori-yt-player, waits for YT.Player.__patched then fetches remote JS and injects as inline text.

(function(){
  'use strict';

  const FIX_SCRIPT_URL = '/raw/jayxdcode/dcma/main/public/embed-patcher.js'; // replace with your remote URL
  const IFRAME_ID = 'hitori-yt-player';
  const WAIT_FOR_PATCHER_MS = 6000;   // wait up to this for YT.Player.__patched inside iframe
  const POLL_INTERVAL = 120;
  const FETCH_TIMEOUT_MS = 8000;      // timeout for fetching remote script

  function log() { try { console.log.apply(console, ['[parent->hitori]'].concat(Array.from(arguments))); } catch(e) {} }

  function getIframe() { return document.getElementById(IFRAME_ID) || null; }

  // Poll until predicate true or timeout. predicate runs in parent but inspects iframe.contentWindow safely with try/catch.
  function waitForIframePredicate(iframe, predicate, timeoutMs) {
    return new Promise((resolve) => {
      const start = Date.now();
      (function poll(){
        try {
          if (!iframe) return resolve(false);
          let ok = false;
          try { ok = predicate(iframe.contentWindow); } catch(e) { ok = false; }
          if (ok) return resolve(true);
        } catch(e){}
        if (Date.now() - start >= timeoutMs) return resolve(false);
        setTimeout(poll, POLL_INTERVAL);
      })();
    });
  }

  // fetch with timeout
  function fetchWithTimeout(url, timeoutMs) {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => reject(new Error('fetch timeout')), timeoutMs);
      fetch(url, { mode: 'cors', credentials: 'omit' })
        .then(res => {
          clearTimeout(timer);
          if(!res.ok) return reject(new Error('fetch failed: ' + res.status));
          return res.text();
        })
        .then(text => resolve(text))
        .catch(err => { clearTimeout(timer); reject(err); });
    });
  }

  // Inject inline JS text into iframe (prepend to head or documentElement)
  function injectInlineScriptTextToIframe(iframe, jsText) {
    try {
      const doc = iframe.contentDocument;
      if(!doc) throw new Error('iframe.contentDocument not available');
      const s = doc.createElement('script');
      s.type = 'text/javascript';
      s.text = jsText;
      (doc.head || doc.documentElement).prepend(s);
      log('injected script text into iframe');
      return true;
    } catch (err) {
      log('injectInlineScriptTextToIframe failed:', err && err.message);
      return false;
    }
  }

  // Try to call the embed hook if present
  async function callEmbedHookIfPresent(iframe) {
    try {
      const w = iframe.contentWindow;
      if(!w) return false;
      if(typeof w.__embedFixFixAll === 'function') {
        try {
          const rv = w.__embedFixFixAll();
          if(rv && typeof rv.then === 'function') {
            await rv;
            log('embed hook (promise) resolved');
          } else {
            log('embed hook (sync) invoked');
          }
          return true;
        } catch(e) {
          log('embed hook threw:', e && e.message);
          return false;
        }
      } else {
        log('embed hook not found in iframe');
        return false;
      }
    } catch(e) {
      log('callEmbedHookIfPresent err:', e && e.message);
      return false;
    }
  }

  // Main flow
  (async function main(){
    const iframe = getIframe();
    if(!iframe) {
      log('iframe #' + IFRAME_ID + ' not found on page');
      return;
    }
    log('found iframe id=' + IFRAME_ID + ' src=', iframe.getAttribute && iframe.getAttribute('src'));

    // Wait for YT patcher inside iframe (safe to access contentWindow properties; catch exceptions)
    const patched = await waitForIframePredicate(iframe, (win) => {
      try {
        return !!(win && win.YT && win.YT.Player && win.YT.Player.__patched);
      } catch(e){ return false; }
    }, WAIT_FOR_PATCHER_MS);

    log('YT.Player.__patched present inside iframe?', patched);

    // Now try to fetch remote patcher JS (no same-origin requirement for fetch)
    let jsText = null;
    try {
      log('fetching remote patcher from', FIX_SCRIPT_URL);
      jsText = await fetchWithTimeout(FIX_SCRIPT_URL, FETCH_TIMEOUT_MS);
      log('fetched patcher, size', jsText.length);
    } catch (err) {
      log('failed to fetch patcher:', err && err.message);
      // still try later to call hook or attempt nothing
    }

    // If iframe is same-origin accessible, inject the fetched script text
    let injected = false;
    try {
      // try to access iframe.document to ensure we can write into it
      const canAccess = !!iframe.contentDocument;
      if(!canAccess) {
        log('iframe.contentDocument inaccessible (cross-origin?) — cannot inject inline script');
      } else if(jsText) {
        injected = injectInlineScriptTextToIframe(iframe, jsText);
      } else {
        log('no jsText to inject (fetch failed)');
      }
    } catch(e) {
      log('injection attempt threw:', e && e.message);
    }

    // attempt to call hook even if we didn't inject (in case it was already present)
    const hookCalled = await callEmbedHookIfPresent(iframe);
    if(!hookCalled && injected) {
      // give it a tick then try again
      await new Promise(r => setTimeout(r, 160));
      await callEmbedHookIfPresent(iframe);
    }

    // final verification log: sample a root-relative img or link if accessible
    try {
      const doc = iframe.contentDocument;
      if(doc) {
        const imgs = doc.querySelectorAll('img[src^="/"]');
        const links = doc.querySelectorAll('link[href*="fonts.gstatic.com"], link[href^="/"]');
        log('post-inject sample counts: images root-relative=', imgs.length, 'link candidates=', links.length);
      }
    } catch(e) {
      log('final verification read failed:', e && e.message);
    }

    log('done injection attempt for #' + IFRAME_ID);
  })();

  // expose helper to retry from console
  window.__parentInjectHitori_retry = function(){ try { main(); } catch(e){ log('manual retry threw', e && e.message); } };

})();
  </script>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>