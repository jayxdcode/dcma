<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hitori ⊙⁠﹏⁠⊙</title>
  <script>
    // Minimal fix for auto load eruda
    (function() {
      if (typeof window.eruda !== 'undefined') return;
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      
      const script = document.createElement('script');
      script.src = isDiscordProxy ? "/src/eruda/eruda.js" : "//cdn.jsdelivr.net/npm/eruda";
      document.body.appendChild(script);
      script.onload = () => {
        window.eruda.init();
        console.log('[eruda] i\'m in, fellas');
      };
    })();
  </script>
  <script src="/raw/jayxdcode/dcma/refs/heads/main/public/debugger.js"></script>
  <script>
    // inject-before-yt-api.js
    (function() {
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      if (!isDiscordProxy) {
        console.log("[yt-api-patcher] skipped patching. reason: not in a discord context")
        return;
      }
      
      const HOST = location.origin + "/yt";
      
      // Ensure YTConfig.host exists before the API checks it
      window.YTConfig = window.YTConfig || {};
      window.YTConfig.host = HOST;
      
      // Patch creation of players once API registers YT.Player
      function patchPlayer() {
        if (!window.YT || !window.YT.Player) return;
        if (window.YT.Player.__patched) return;
        
        const RealPlayer = window.YT.Player;
        
        function PatchedPlayer(el, opts) {
          opts = opts || {};
          // force host to our proxy
          opts.host = HOST;
          return new RealPlayer(el, opts);
        }
        // preserve prototype and static props
        PatchedPlayer.prototype = RealPlayer.prototype;
        Object.getOwnPropertyNames(RealPlayer).forEach(k => {
          if (!(k in PatchedPlayer)) PatchedPlayer[k] = RealPlayer[k];
        });
        PatchedPlayer.__patched = true;
        window.YT._RealPlayer = RealPlayer;
        window.YT.Player = PatchedPlayer;
      }
      
      // Hook into the usual ready callbacks and poll fallback
      const orig1 = window.onYouTubeIframeAPIReady;
      window.onYouTubeIframeAPIReady = function() {
        if (typeof orig1 === "function") try { orig1(); } catch (e) {}
        patchPlayer();
      };
      const orig2 = window.onYouTubePlayerAPIReady;
      window.onYouTubePlayerAPIReady = function() {
        if (typeof orig2 === "function") try { orig2(); } catch (e) {}
        patchPlayer();
      };
      
      // Poll until available (cleans up)
      const t = setInterval(() => {
        patchPlayer();
        if (window.YT && window.YT.Player && window.YT.Player.__patched) {
          console.log("[yt-api-patcher] patch done")
          clearInterval(t);
        }
      }, 60);
    })();
  </script>
  <script>
    // parent-robust-injector.js
    (function() {
      'use strict';
      const FIX_SCRIPT_URL = '/raw/jayxdcode/dcma/refs/heads/main/public/embed-patcher.js'; // your hosted script (same-origin path)
      const IFRAME_ID = 'hitori-yt-player';
      const MAX_WAIT_MS = 8000;
      const POLL_INTERVAL = 120;
      
      function logParent() {
        try { console.log.apply(console, ['[parent-injector]'].concat(Array.from(arguments))); } catch (e) {}
      }
      
      function logIframe(iframe, ...args) {
        try {
          // try to call iframe console if same-origin
          if (iframe && iframe.contentWindow && iframe.contentWindow.console) {
            iframe.contentWindow.console.log.apply(iframe.contentWindow.console, ['[parent->iframe]'].concat(args));
          }
        } catch (e) {}
      }
      
      function elementReady(selector, timeout = MAX_WAIT_MS) {
        return new Promise((resolve) => {
          const start = Date.now();
          (function poll() {
            const el = document.getElementById(IFRAME_ID) || document.querySelector(selector);
            if (el) return resolve(el);
            if (Date.now() - start > timeout) return resolve(null);
            setTimeout(poll, POLL_INTERVAL);
          })();
        });
      }
      
      function isSameOrigin(iframe) {
        try {
          // accessing contentDocument throws if cross-origin
          return !!(iframe && iframe.contentDocument);
        } catch (e) {
          return false;
        }
      }
      
      async function tryInjectViaSrc(iframe, scriptUrl) {
        try {
          const doc = iframe.contentDocument;
          if (!doc) throw new Error('no contentDocument');
          const s = doc.createElement('script');
          s.src = scriptUrl;
          s.defer = true;
          s.onload = function() { logParent('injected via src loaded');
            logIframe(iframe, 'script[src] loaded'); };
          s.onerror = function(ev) { logParent('script[src] failed to load', ev);
            logIframe(iframe, 'script[src] failed'); };
          (doc.head || doc.documentElement).appendChild(s);
          return true;
        } catch (err) {
          logParent('tryInjectViaSrc error:', err && err.message);
          return false;
        }
      }
      
      async function tryInjectInline(iframe, scriptUrl) {
        try {
          const doc = iframe.contentDocument;
          if (!doc) throw new Error('no contentDocument');
          
          // fetch script text (same-origin only)
          const res = await fetch(scriptUrl, { credentials: 'same-origin' });
          if (!res.ok) throw new Error('fetch failed: ' + res.status);
          const js = await res.text();
          
          const s = doc.createElement('script');
          s.type = 'text/javascript';
          s.text = js;
          (doc.head || doc.documentElement).prepend(s);
          logParent('injected inline script text into iframe');
          logIframe(iframe, 'inline script injected');
          return true;
        } catch (err) {
          logParent('tryInjectInline error:', err && err.message);
          return false;
        }
      }
      
      async function callEmbedHook(iframe) {
        try {
          if (!isSameOrigin(iframe)) throw new Error('not same-origin');
          const w = iframe.contentWindow;
          if (typeof w.__embedFixFixAll === 'function') {
            // call it and await if it returns a Promise
            const rv = w.__embedFixFixAll();
            if (rv && typeof rv.then === 'function') {
              rv.then(r => {
                logParent('embed hook returned (promise):', r);
                logIframe(iframe, 'embed hook returned (promise):', r && r.stats ? r.stats : r);
              }).catch(e => {
                logParent('embed hook promise rejected', e);
              });
            } else {
              logParent('embed hook returned:', rv);
              logIframe(iframe, 'embed hook returned:', rv);
            }
            return true;
          } else {
            logParent('__embedFixFixAll not present (yet)');
            return false;
          }
        } catch (e) { logParent('callEmbedHook err:', e && e.message); return false; }
      }
      
      async function injectFlow() {
        const iframe = await elementReady('#' + IFRAME_ID, MAX_WAIT_MS);
        if (!iframe) {
          logParent('iframe not found with id="' + IFRAME_ID + '"');
          return;
        }
        logParent('iframe element found, src=', iframe.getAttribute && iframe.getAttribute('src'));
        
        // Wait for same-origin (up to MAX_WAIT_MS)
        const start = Date.now();
        while (!isSameOrigin(iframe) && Date.now() - start < MAX_WAIT_MS) {
          logParent('waiting for iframe to become same-origin...');
          await new Promise(r => setTimeout(r, POLL_INTERVAL));
        }
        if (!isSameOrigin(iframe)) {
          logParent('iframe is not same-origin after wait — cannot inject inline. Check your /yt mapping and host origin.');
          // Try best-effort: if you can, insert a top-level <script src> into the parent that creates an iframe with script src? (not included).
          return;
        }
        logParent('iframe is same-origin — proceeding with injection');
        
        // Strategy 1: insert <script src="..."> into iframe (CSP-friendly)
        let ok = await tryInjectViaSrc(iframe, FIX_SCRIPT_URL);
        // Wait a bit for the script to load and set up the hook
        await new Promise(r => setTimeout(r, 200));
        if (!ok) {
          logParent('script[src] injection attempted but reported failure — trying inline fetch+inject fallback');
          ok = await tryInjectInline(iframe, FIX_SCRIPT_URL);
        }
        
        // call hook if present
        const hooked = await callEmbedHook(iframe);
        if (!hooked) {
          // allow a few retries with delay (script may not have executed yet)
          for (let i = 0; i < 6 && !hooked; i++) {
            await new Promise(r => setTimeout(r, 250));
            if (await callEmbedHook(iframe)) break;
          }
        }
        
        // Final check: inspect a couple of elements inside iframe to verify paths were rewritten
        try {
          const doc = iframe.contentDocument;
          // sample a few nodes
          const imgs = doc.querySelectorAll('img[src^="/"]');
          const links = doc.querySelectorAll('link[href*="fonts.gstatic.com"], link[href^="/"]');
          logParent('post-inject sample counts: images root-relative=', imgs.length, 'link candidates=', links.length);
          logIframe(iframe, 'post-inject sample counts', { imgs: imgs.length, links: links.length });
        } catch (e) {
          logParent('final verification read failed:', e && e.message);
        }
      }
      
      // Run
      injectFlow().catch(e => logParent('injectFlow top-level err', e && e.message));
      
      // Expose helper for manual retry from console
      window.__parentInjector_retry = function() { injectFlow().catch(e => logParent('retry err', e && e.message)); };
      
    })();
  </script>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>