<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hitori ⊙⁠﹏⁠⊙</title>
  <script>
    // Minimal fix for auto load eruda
    (function() {
      if (typeof window.eruda !== 'undefined') return;
      
      const script = document.createElement('script');
      script.src = isDiscordProxy ? "/src/eruda/eruda.js" : "//cdn.jsdelivr.net/npm/eruda";
      document.body.appendChild(script);
      script.onload = () => {
        window.eruda.init();
        console.log('[eruda] i\'m in, fellas');
      };
    })();
  </script>
  <script>
    // inject-before-yt-api.js
    (function() {
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      if (!isDiscordProxy) {
        console.log("[yt-api-patcher] skipped patching. reason: not in a discord context")
        return;
      }
      
      const HOST = location.origin + "/yt";
      
      // Ensure YTConfig.host exists before the API checks it
      window.YTConfig = window.YTConfig || {};
      window.YTConfig.host = HOST;
      
      // Patch creation of players once API registers YT.Player
      function patchPlayer() {
        if (!window.YT || !window.YT.Player) return;
        if (window.YT.Player.__patched) return;
        
        const RealPlayer = window.YT.Player;
        
        function PatchedPlayer(el, opts) {
          opts = opts || {};
          // force host to our proxy
          opts.host = HOST;
          return new RealPlayer(el, opts);
        }
        // preserve prototype and static props
        PatchedPlayer.prototype = RealPlayer.prototype;
        Object.getOwnPropertyNames(RealPlayer).forEach(k => {
          if (!(k in PatchedPlayer)) PatchedPlayer[k] = RealPlayer[k];
        });
        PatchedPlayer.__patched = true;
        window.YT._RealPlayer = RealPlayer;
        window.YT.Player = PatchedPlayer;
      }
      
      // Hook into the usual ready callbacks and poll fallback
      const orig1 = window.onYouTubeIframeAPIReady;
      window.onYouTubeIframeAPIReady = function() {
        if (typeof orig1 === "function") try { orig1(); } catch (e) {}
        patchPlayer();
      };
      const orig2 = window.onYouTubePlayerAPIReady;
      window.onYouTubePlayerAPIReady = function() {
        if (typeof orig2 === "function") try { orig2(); } catch (e) {}
        patchPlayer();
      };
      
      // Poll until available (cleans up)
      const t = setInterval(() => {
        patchPlayer();
        if (window.YT && window.YT.Player && window.YT.Player.__patched) {
          console.log("[yt-api-patcher] patch done")
          clearInterval(t);
        }
      }, 60);
    })();
  </script>
  <script>
    // parent-inject-fetch.js
    (function() {
      'use strict';
      
      const isDiscordProxy = window.location.hostname.includes('discordsays.com');
      if (!isDiscordProxy) {
        console.log("[iframe-patcher] skipped patching. reason: not in a discord context")
        return;
      }
      
      // URL where the combined embed-fix script is hosted (on same origin)
      const FIX_SCRIPT_URL = '/raw/jayxdcode/dcma/refs/heads/main/public/embed-patcher.js';
      
      // Try injecting into a single iframe (returns a Promise)
      async function fetchAndInject(iframe, scriptUrl = FIX_SCRIPT_URL) {
        try {
          // ensure iframe is accessible (same-origin)
          const doc = iframe.contentDocument;
          if (!doc) throw new Error('no contentDocument (cross-origin or not ready)');
          
          // fetch text
          const res = await fetch(scriptUrl, { credentials: 'same-origin' });
          if (!res.ok) throw new Error('script fetch failed: ' + res.status);
          const js = await res.text();
          
          // create script element and append
          const s = doc.createElement('script');
          s.type = 'text/javascript';
          s.text = js;
          (doc.head || doc.documentElement).appendChild(s);
          
          // optional: call the hook if the script exposes it
          try { iframe.contentWindow.__embedFixFixAll && iframe.contentWindow.__embedFixFixAll(); } catch (e) {}
          
          return true;
        } catch (err) {
          console.warn('fetchAndInject failed:', err);
          return false;
        }
      }
      
      // helper: wait until iframe becomes same-origin-ready (poll up to timeout)
      function waitForSameOrigin(iframe, timeout = 3000, interval = 100) {
        return new Promise((resolve) => {
          const start = Date.now();
          
          function check() {
            try {
              // access document; if cross-origin will throw
              const doc = iframe.contentDocument;
              if (doc) return resolve(true);
            } catch (e) { /* ignore */ }
            if (Date.now() - start > timeout) return resolve(false);
            setTimeout(check, interval);
          }
          check();
        });
      }
      
      // convenience: inject when iframe loads (or is already ready)
      async function injectWhenReady(iframe) {
        if (!iframe) return false;
        // if already same-origin, inject immediately
        try {
          if (iframe.contentDocument) return await fetchAndInject(iframe);
        } catch (e) {}
        // otherwise wait for load and same-origin
        return new Promise((resolve) => {
          function onload() {
            waitForSameOrigin(iframe, 5000).then((ready) => {
              if (ready) {
                fetchAndInject(iframe)
                  .then(() => {
                    console.log('[iframe-patcher] patch done')
                  })
                  .then(resolve);
              } else {
                console.warn('iframe not same-origin after load; injection skipped');
                resolve(false);
              }
            });
            iframe.removeEventListener('load', onload);
          }
          iframe.addEventListener('load', onload);
        });
      }
      
      // execute
      const iframe = document.getElementById('hitori-yt-player');
      injectWhenReady(iframe);
      
      // Expose helpers on window for manual use
      window.__injectEmbedFix_fetchAndInject = fetchAndInject;
      window.__injectEmbedFix_injectWhenReady = injectWhenReady;
    })();
  </script>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>